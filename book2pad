#!/usr/bin/env python
#-*- coding: utf8 -*-
import os
import sys
import hashlib
import shutil
import argparse
import re
import traceback
import pyexifinfo as exif
import zipfile
import time
from biplist import *
from binaryornot.check import is_binary

ipad_root = ''
ibooks_plist = 'Books/Purchases/Purchases.plist'
books_transfered_num = 0
books_failed_list = []
books_adding = ''

class IBooks():
    def __init__(self, plist):
        self.plist = plist
        self.ibooks_path = os.path.basename(self.plist)
        self.init_tree()

    def init_tree(self):
        self.is_binary = False
        self.tree = {
            'Books': []
        }
        if os.path.exists(self.plist):
            self.is_binary = is_binary(self.plist)
            try:
                self.tree = readPlist(self.plist)
            except:
                print "Unexpected error:", sys.exc_info()[0]

    def add_book(self, book):
        self.tree['Books'].append(book.tree)
        self.save()

    def check_book(self, book):
        in_flag = False
        for item in self.tree['Books']:
            if item['Package Hash'] == hash_md5(book):
                in_flag = True
                continue

        return in_flag

    def clear(self):
        books = walkdir(self.ibooks_path)
        for book in books:
            if not self.check_book(book):
                if os.path.isfile(book):
                    os.remove(book)
                elif os.path.isdir(book):
                    shutil.rmtree(book)

    def save(self, force = False):
        global books_transfered_num
        try:
            writePlist(self.tree, self.plist, binary=self.is_binary)
            books_transfered_num += 1
        except IOError:
            if force:
                print("\nIf you seen this message, please open your ibooks. Don't disconnect your ipad!")
                time.sleep(10)
                self.save(force)

        except:
            self.clear()
            print "Unexpected error:", sys.exc_info()[0]
            raise


class Book():
    def __init__(self, book):
        self.tree = {}
        self.add_attrib('Name', os.path.splitext(os.path.basename(book))[0])
        self.add_attrib('Inserted-By-iBooks', False)
        self.add_attrib('Package Hash', hash_md5(book))
        self.add_attrib('Path', os.path.basename(book))

    def add_attrib(self, key, value):
        self.tree[key] = value

    def get_attrib(self, key):
        return self.tree[key]


def hash_md5(book):
    md5 = hashlib.md5()
    md5.update(open(book, 'rb').read())

    return md5.hexdigest().upper()


def get_string(val):
    if isinstance(val, int):
        return str(val)

    if isinstance(val, str):
        return unicode(val, 'utf8')

    if isinstance(val, list):
        new_val = []
        for item in val:
            new_val.append(get_string(item))

        return ' '.join(new_val)

    return val


def get_file_info(book):
    result = {
        'title': '',
        'author': ''
    }
    metadata = exif.get_json(book)

    filename = os.path.splitext(get_string(metadata[0]['File:FileName']))[0]
    file_info = filename.split('-')

    result['title'] = filename
    result['author'] = get_string(file_info[-1])

    return result


def get_book_info(book):
    result = {
        'title': '',
        'genre': '',
        'author': ''
    }

    folder_path = os.path.dirname(book)
    path, genre = os.path.split(folder_path)
    result['genre'] = get_string(genre)

    metadata = exif.get_json(book)

    try:
        title = get_string(metadata[0]['XMP:Title'])
        author = get_string(metadata[0]['XMP:Creator'])
    except:
        file_info = get_file_info(book)

        title = file_info['title']
        author = file_info['author']

    search_obj = re.search(r'[A-Za-z0-9]+', author, re.M|re.I)
    if search_obj and len(search_obj.group(0)) > 10:
        file_info = get_file_info(book)

        title = file_info['title']
        author = file_info['author']

    result['title'] = title
    result['author'] = author

    return result


def addbooks(root_dir, books):
    global books_failed_list
    global books_adding
    book_num = len(books)
    if book_num == 0:
        print 'No pdf or epub file found!'
        return

    # init vars
    plist = os.path.join(root_dir, ibooks_plist)
    dest = os.path.dirname(plist)
    ibooks = IBooks(plist)

    if not os.path.exists(dest):
        os.makedirs(dest)

    # init processing bar
    bar_len = int(int(os.popen('stty size', 'r').read().split()[1])*.75)
    step_len = 0
    print('Start transferring...')
    sys.stdout.write("[%s]" % (" " * (bar_len+1)))
    sys.stdout.flush()
    sys.stdout.write('%s%s' % ("\b" * (bar_len+2),'>'))
    sys.stdout.flush()

    for book in books:
        book = book.decode('utf-8')
        ext = os.path.splitext(book)[-1].upper()
        book_dest_folder = os.path.join(dest, os.path.basename(book))

        if not os.path.exists(book) or (ext not in ['.PDF', '.EPUB']):
            books_failed_list.append(book)
            continue

        if '.PDF' == ext:
            if ibooks.check_book(book):
                books_failed_list.append(book)
                continue

            if (not os.path.exists(book_dest_folder)) or hash_md5(book_dest_folder) != hash_md5(book):
                books_adding = book_dest_folder
                shutil.copyfile(book, book_dest_folder)
        elif '.EPUB' == ext:
            if ibooks.check_book(book):
                books_failed_list.append(book)
                continue

            os.mkdir(book_dest_folder)
            books_adding = book_dest_folder
            with zipfile.ZipFile(book, "r") as z:
                z.extractall(book_dest_folder)

        book_info = get_book_info(book)

        book_obj = Book(book)
        book_obj.add_attrib('Genre', book_info['genre'])
        if book_info['title']:
            book_obj.add_attrib('Name', book_info['title'])
        book_obj.add_attrib('Artist', book_info['author'])

        ibooks.add_book(book_obj)
        books_adding = ''

        step_len += bar_len
        if step_len >= book_num:
            sys.stdout.write("\b%s>" % '='*int(float(step_len)/book_num))
            sys.stdout.flush()
            step_len = step_len%book_num

    ibooks.save(True)
    transfer_info()


def transfer_info(prefix = 'Finished'):
    sys.stdout.write('\n')
    print('%s: %s books transfered' % (prefix, str(books_transfered_num)))
    if len(books_failed_list):
        print('The following books are not transfered:')
        for book in books_failed_list:
            print(book)


def walkdir(dirname):
    books = []
    for cur, _dirs, files in os.walk(dirname):
        for f in files:
            real_path = os.path.join(cur, f)
            books.append(real_path)

    return books


def check_pad(path):
    ibooks_path = os.path.join(path, 'Books')
    ibooks_purchases_path = os.path.join(ibooks_path, 'Purchases')
    check_path = ''
    is_pad = True
    if not os.path.exists(ibooks_path):
        is_pad = False
        check_path = ibooks_path
    elif not os.path.exists(ibooks_purchases_path):
        is_pad = False
        check_path = ibooks_purchases_path

    if is_pad:
        return

    print('Seems you give wrong ipad mount point, please check!')
    print("Path not exists: %s" % check_path)
    sys.exit(-1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Transfer books to ipad')
    parser.add_argument('-d', '--ipad', action='store', dest='IPAD_MOUNTED_POINT',
                        help='Indicate path ipad is mounted; if omitted, the current working directory will be treated.')
    parser.add_argument('-b', '--book', type=str, required=True, action='append', dest='BOOK', nargs='+',
                        help='Indicate book path to transfer; if path is a directory, all books under that will be transfered.')
    parser.add_argument('--version', action='version', version='%(prog)s 1.0')

    args = parser.parse_args()
    book_list = args.BOOK[0]

    if args.IPAD_MOUNTED_POINT is None:
        ipad_root = os.getcwd()
    else:
        ipad_root = os.path.abspath(args.IPAD_MOUNTED_POINT)

    try:
        books = []
        check_pad(ipad_root)

        for book_path in book_list:
            if os.path.isdir(book_path):
                books += walkdir(book_path)
            else:
                books.append(book_path)

        if len(books) > 0:
            addbooks(os.path.abspath(ipad_root), books)
    except KeyboardInterrupt:
        plist = os.path.join(ipad_root, ibooks_plist)
        ibooks = IBooks(plist)
        ibooks.clear()

        if len(books_adding) > 0:
            if os.path.isfile(books_adding):
                os.remove(books_adding)
            elif os.path.isdir(books_adding):
                shutil.rmtree(books_adding)

        transfer_info('Interrupted')

    except Exception,e:
        traceback.print_exc()